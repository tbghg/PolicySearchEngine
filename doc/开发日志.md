# 开发日志

## 问题记录

| 序号 | 日期    | 问题                                      | 解决办法                             | 备注                      | 解决日期 / 上线日期 |
|:---|-------|-----------------------------------------|----------------------------------|-------------------------|-------------|
| 1  | 12.28 | 爬取meta时，标题爬取不全，字多时是省略号，只有打开文章内部才能看到真实标题 | DB中写入标识位，打开文章内部时对标题进行替换，同时标记     |                         |             |
| 2  | 12.28 | 如何进行监控做到内容更新                            | 爬到meta后看DB中有无这个url，同时比较日期，每天扫一次吧 | 肯定不能全量重新爬取，那样还得重新建索引    |             |
| 3  | 12.29 | 目录页中可能有相同的meta，需要去重                     | [meta去重](#解决办法-meta去重)           |                         | 12.29       |
| 4  | 1.10  | 创建多少个colly对象，哪些地方需要创建                   | [创建colly对象](#解决办法-创建colly对象)     |                         |             |
| 5  | 1.10  | 本次扫描完的meta数据何时爬取内容                      | [何时爬取内容数据](#解决办法-何时爬取内容数据)       |                         |             |
| 6  | 1.10  | ES是如何运作的，如何把数据接入ES                      | [如何接入ES](#解决办法-接入ES)             |                         |             |
| 7  | 1.10  | 不同部门之间跑要做成什么形式，要并发吗                     | 不并发，一个部门一个部门的串行处理即可              | 没必要，每天定时跑一遍的项目，对时间没有要求的 |             |
| 8  | 1.13  | 监控内容更新具体实现                              | [监控具体实现](#解决办法-监控具体实现)           |                         |             |
| 9  | 1.13  | meta运行完成后如何通知content启动，包括定时监控           | [content启动时间](#解决办法-content启动时间) |                         |             |
| 9  | 1.14  | content部分，标题和内容分两个OnHTML时，更新DB不好更新      | 分别更新吧，先更新title                   |                         |             |

## 开发节点

| 序号 | 日期   | 内容                                       | 备注 |
|----|------|------------------------------------------|----|
| 1  | 1.10 | 爬虫项目整体结构，中央科技部的meta部分写好了，但还未接入DB，监控也不知所措 |    |
| 2  | 1.10 | 每个meta和部门应该对应起来，做成一个接口，然后交给main去跑，简化项目结构 |    |
| 3  | 1.10 | meta接入数据库                                |    |
| 4  | 1.13 | meta监控，每天运行一次，插入新的url                    |    |
| 5  | 1.13 | 重构service                                |    |
| 6  | 1.13 | 中央科技部content试编写                          |    |
| 7  | 1.14 | 中央科技部所有content编写完成，但是没有接入DB              |    |
| 8  | 1.20 | 接入中央文化部，进度与科技部同步                         |    |
| 9  | 1.23 | 简化collector写法                            |    |

## 碎碎念

| 序号 | 日期   | 内容                                                                     | 备注    |
|----|------|------------------------------------------------------------------------|-------|
| 1  | 1.10 | 一开始以为挺简单的，但后来发现中央的各个部门格式都不一样，省里面就更不要说了，一个部门里面文章的格式竟然还都不一样，估计有五六种，人已经麻了 | 😵‍💫 |


### 解决办法-meta去重

打算使用colly库自带的缓存方法去重，但是发现自带的以colly对象为单位统一全做缓存，无法定制化处理，如把目录页单独剔除缓存。

解决方案：

1. 再创建个colly对象，两个一个用缓存一个不用即可，但是有些啰嗦
2. 把`github.com/gocolly/redisstorage`改一下，做些定制化处理

最终选用方法二实现，源代码是把url做个处理得到requestID，然后加前缀作为redis的key，这个源代码来自colly库，我肯定是改不动的，但是redisstorage库就好改很多，对Visited做一下定制化处理即可

```go
	if checkRevisit && !c.AllowURLRevisit && method == "GET" {
		h := fnv.New64a()
		h.Write([]byte(u))
		uHash := h.Sum64()
		visited, err := c.store.IsVisited(uHash)
		if err != nil {
			return err
		}
		if visited {
			return ErrAlreadyVisited
		}
		return c.store.Visited(uHash)
	}
```

### 解决办法-创建colly对象

每个colly对象对应着不同的OnHTML方法，爬取meta时如果一起把内容爬了，那就需要把它们的OnHTML写一块，肯定是不太合理的。

每个部门都有一个自己的meta，meta的整个运行顺序如下：

1. 获取所有目录页的url【这里说不定得开一个colly去获取，目前是写死的】
2. 创建一个colly对象，依次Visit目录页url
3. 爬取meta信息并写入DB，不需要递归往下深入

meta处理好后，就是内容的爬取，怎么通知已经可以爬内容了是个问题，考虑以下三种：

1. channel
2. MQ
3. meta全部爬完后再统一启动

这个单独开个问题吧

内容部分根据不同的正则规则去开colly对象，也就是说一个部门一个meta的colly对象，多个内容的colly对象

### 解决办法-何时爬取内容数据

一个部门 ==> 一个meta的colly对象 多个内容的colly对象

meta处理完毕后写入DB，然后启动内容的colly对象，去处理DB中对应部门的meta，该数据如果是在今天更新的，那就爬取他

### 解决办法-接入ES

【PENDING】额，还没详细了解过ES，虽然知道可以把mysql的表直接接入，但是具体没学，等学完ES才方便确定表结构之类的，现在先省略

### 解决办法-监控具体实现

有个问题，怎么看文章是不是修改的，我想的url作唯一索引，url相同则比较发布日期，日期相同认为未修改。但是发布的日期基本都是精确到日，同一天做出修改的化其实不太准，最后想了想，认为这种政策文件就不应该出现修改的情况，毕竟是要公示的政策法规，不可能来回修改的，就算要改也是发布一个新的，命名为订正之类的。

所以就没必要检测文章修改了，直接监测新文章就行，DB中url存在则忽略，不存在则插入

### 解决办法-content启动时间

这个当前很尴尬的地方在我把meta和content拆开写了，两个属于不同的模块，外部由service统一运行，但是meta的定时运行是放在每个部门内部的，定时运行时外部service又没法控制

两种方案：
1. 定时时间还是在部门内部，内部运行完成后由内部运行content相关流程
2. 运行时间以配置文件形式存在，统一由service设置，meta和content提供自己的watch函数，service外面套个大的就行，然后定时运行

毫无疑问，方案二
