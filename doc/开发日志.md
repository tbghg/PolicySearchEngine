# 开发日志

## 问题记录

| 序号 | 日期    | 问题                                      | 解决办法                             | 备注                      | 解决日期 / 上线日期 |
|:---|-------|-----------------------------------------|----------------------------------|-------------------------|-------------|
| 1  | 12.28 | 爬取meta时，标题爬取不全，字多时是省略号，只有打开文章内部才能看到真实标题 | DB中写入标识位，打开文章内部时对标题进行替换，同时标记     |                         |             |
| 2  | 12.28 | 如何进行监控做到内容更新                            | 爬到meta后看DB中有无这个url，同时比较日期，每天扫一次吧 | 肯定不能全量重新爬取，那样还得重新建索引    |             |
| 3  | 12.29 | 目录页中可能有相同的meta，需要去重                     | [meta去重](#解决办法-meta去重)           |                         | 12.29       |
| 4  | 1.10  | 创建多少个colly对象，哪些地方需要创建                   | [创建colly对象](#解决办法-创建colly对象)     |                         |             |
| 5  | 1.10  | 本次扫描完的meta数据何时爬取内容                      | [何时爬取内容数据](#解决办法-何时爬取内容数据)       |                         |             |
| 6  | 1.10  | ES是如何运作的，如何把数据接入ES                      | [如何接入ES](#解决办法-接入ES)             |                         |             |
| 7  | 1.10  | 不同部门之间跑要做成什么形式，要并发吗                     | 不并发，一个部门一个部门的串行处理即可              | 没必要，每天定时跑一遍的项目，对时间没有要求的 |             |

## 开发节点

| 序号 | 日期   | 内容                                       | 备注 |
|----|------|------------------------------------------|----|
| 1  | 1.10 | 爬虫项目整体结构，中央科技部的meta部分写好了，但还未接入DB，监控也不知所措 |    |
| 2  | 1.10 | 每个meta和部门应该对应起来，做成一个接口，然后交给main去跑，简化项目结构 |    |
| 3  | 1.10 | meta接入数据库                                |    |

## 碎碎念

| 序号 | 日期   | 内容                                                                     | 备注    |
|----|------|------------------------------------------------------------------------|-------|
| 1  | 1.10 | 一开始以为挺简单的，但后来发现中央的各个部门格式都不一样，省里面就更不要说了，一个部门里面文章的格式竟然还都不一样，估计有五六种，人已经麻了 | 😵‍💫 |


### 解决办法-meta去重

打算使用colly库自带的缓存方法去重，但是发现自带的以colly对象为单位统一全做缓存，无法定制化处理，如把目录页单独剔除缓存。

解决方案：

1. 再创建个colly对象，两个一个用缓存一个不用即可，但是有些啰嗦
2. 把`github.com/gocolly/redisstorage`改一下，做些定制化处理

最终选用方法二实现，源代码是把url做个处理得到requestID，然后加前缀作为redis的key，这个源代码来自colly库，我肯定是改不动的，但是redisstorage库就好改很多，对Visited做一下定制化处理即可

```go
	if checkRevisit && !c.AllowURLRevisit && method == "GET" {
		h := fnv.New64a()
		h.Write([]byte(u))
		uHash := h.Sum64()
		visited, err := c.store.IsVisited(uHash)
		if err != nil {
			return err
		}
		if visited {
			return ErrAlreadyVisited
		}
		return c.store.Visited(uHash)
	}
```

### 解决办法-创建colly对象

每个colly对象对应着不同的OnHTML方法，爬取meta时如果一起把内容爬了，那就需要把它们的OnHTML写一块，肯定是不太合理的。

每个部门都有一个自己的meta，meta的整个运行顺序如下：

1. 获取所有目录页的url【这里说不定得开一个colly去获取，目前是写死的】
2. 创建一个colly对象，依次Visit目录页url
3. 爬取meta信息并写入DB，不需要递归往下深入

meta处理好后，就是内容的爬取，怎么通知已经可以爬内容了是个问题，考虑以下三种：

1. channel
2. MQ
3. meta全部爬完后再统一启动

这个单独开个问题吧

内容部分根据不同的正则规则去开colly对象，也就是说一个部门一个meta的colly对象，多个内容的colly对象

### 解决办法-何时爬取内容数据

一个部门 ==> 一个meta的colly对象 多个内容的colly对象

meta处理完毕后写入DB，然后启动内容的colly对象，去处理DB中对应部门的meta，该数据如果是在今天更新的，那就爬取他

### 解决办法-接入ES

【PENDING】额，还没详细了解过ES，虽然知道可以把mysql的表直接接入，但是具体没学，等学完ES才方便确定表结构之类的，现在先省略
